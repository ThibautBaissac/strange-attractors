<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Animated Strange Attractors</title>
  <style>
    /* CSS Variables for easy theming */
    :root {
      --primary-color: #4a90e2;
      --background-color: rgba(255, 255, 255, 0.85);
      --text-color: #333;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      --accent-color: #f0f0f0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      background: #f4f7f9;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: grab;
    }

    #toggleControls {
      position: absolute;
      top: 5px;
      left: 5px;
      z-index: 100;
      background: #ccc;
      border: none;
      padding: 5px;
      color: #fff;
      cursor: pointer;
    }

    #ui {
      position: absolute;
      top: 35px;
      left: 5px;
      z-index: 100;
      background: var(--background-color);
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      max-width: 250px;
    }

    /* Form elements styling */
    #ui label {
      font-size: 0.9rem;
      margin-bottom: 5px;
      color: var(--text-color);
      display: inline-block
    }

    #ui select,
    #ui input[type="number"],
    #ui input[type="checkbox"] {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      background: #fff;
    }

    #ui input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
    }


    .range-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    #speedSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      background: #ddd;
      border-radius: 3px;
      outline: none;
    }

    #speedSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      transition: background 0.3s;
    }

    #speedSlider::-webkit-slider-thumb:hover {
      background: #3a78c2;
    }

    #speedValue {
      width: 40px;
      text-align: center;
      font-size: 0.9rem;
      color: var(--text-color);
    }

    #pointCounter {
      display: inline-block;
      background: var(--accent-color);
      padding: 5px 10px;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      color: var(--text-color);
      text-align: center;
      margin-bottom: 15px;
    }

    #ui button {
      width: 100%;
      padding: 10px;
      border: none;
      border-radius: var(--border-radius);
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.3s;
      margin-bottom: 10px;
      color: #fff;
      background: var(--primary-color);
    }

    #ui button:hover {
      background: #3a78c2;
    }

    .play-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .xyz-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .xyz-group button {
      flex: 1;
      padding: 8px;
      border-radius: 50px;
      font-size: 0.9rem;
    }
  </style>
  <script type="module">
    import {
      mat4
    } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.2/src/index.js';

    /*******************************
     * Utility: GLUtil
     *******************************/
    class GLUtil {
      static initWebGL(canvas) {
        let gl = canvas.getContext("webgl2");
        if (!gl) {
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
          if (!gl) {
            alert("Unable to initialize WebGL. Your browser may not support it.");
          }
        }
        return gl;
      }
      static loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("Error compiling shader: " + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      static initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = GLUtil.loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = GLUtil.loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
          return null;
        }
        return shaderProgram;
      }
    }

    /*******************************
     * Shader Sources for Attractor
     *******************************/
    const vsSource = `#version 300 es
        in vec3 aPosition;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uModelViewMatrix;
        out vec3 vPosition;
        void main() {
          vec4 pos = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
          gl_Position = pos;
          gl_PointSize = 2.5;
          vPosition = aPosition;
        }
      `;
    const fsSource = `#version 300 es
        precision mediump float;
        in vec3 vPosition;
        uniform int uColormap;
        out vec4 fragColor;
        float smoothStepCustom(float edge0, float edge1, float x) {
          float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
          return t * t * (3.0 - 2.0 * t);
        }
        vec3 viridisColormap(float t) {
          return vec3(
            0.5 + 0.5 * sin(6.2831 * t + 0.0),
            0.5 + 0.5 * sin(6.2831 * t + 2.094),
            0.5 + 0.5 * sin(6.2831 * t + 4.188)
          );
        }
        vec3 parulaSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 0.5);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 1.2);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 2.0);
          return vec3(red, green, blue);
        }
        vec3 plasmaSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 0.0);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 0.8);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 1.6);
          return vec3(red, green, blue);
        }
        vec3 thermalSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 1.0);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 0.0);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 2.0);
          return vec3(red, green, blue);
        }
        void main() {
          vec2 coord = gl_PointCoord - vec2(0.5);
          float dist = length(coord);
          float alpha = 1.0 - smoothStepCustom(0.45, 0.5, dist);
          float t = fract(vPosition.z * 0.1);
          vec3 color;
          if(uColormap == 0) {
            color = viridisColormap(t);
          } else if(uColormap == 1) {
            color = parulaSinColormap(t);
          } else if(uColormap == 2) {
            color = plasmaSinColormap(t);
          } else if(uColormap == 3) {
            color = thermalSinColormap(t);
          } else {
            color = viridisColormap(t);
          }
          fragColor = vec4(color, alpha);
        }
      `;

    /*******************************
     * Shader Sources for Particle Flow
     *******************************/
    const particleVsSource = `#version 300 es
        in vec3 aPosition;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uModelViewMatrix;
        uniform float uPointSize;
        out vec3 vPos;
        void main() {
          vec4 pos = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
          gl_Position = pos;
          gl_PointSize = uPointSize;
          vPos = aPosition;
        }
      `;
    const particleFsSource = `#version 300 es
        precision mediump float;
        in vec3 vPos;
        uniform int uColormap;
        out vec4 fragColor;
        float smoothStepCustom(float edge0, float edge1, float x) {
          float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
          return t * t * (3.0 - 2.0 * t);
        }
        vec3 viridisColormap(float t) {
          return vec3(
            0.5 + 0.5 * sin(6.2831 * t + 0.0),
            0.5 + 0.5 * sin(6.2831 * t + 2.094),
            0.5 + 0.5 * sin(6.2831 * t + 4.188)
          );
        }
        vec3 parulaSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 0.5);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 1.2);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 2.0);
          return vec3(red, green, blue);
        }
        vec3 plasmaSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 0.0);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 0.8);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 1.6);
          return vec3(red, green, blue);
        }
        vec3 thermalSinColormap(float t) {
          float red   = 0.5 + 0.5 * sin(6.2831 * t + 1.0);
          float green = 0.5 + 0.5 * sin(6.2831 * t + 0.0);
          float blue  = 0.5 + 0.5 * sin(6.2831 * t + 2.0);
          return vec3(red, green, blue);
        }
        void main() {
          vec2 coord = gl_PointCoord - vec2(0.5);
          float dist = length(coord);
          float alpha = 1.0 - smoothStepCustom(0.3, 0.5, dist);
          float t = fract(vPos.z * 0.1);
          vec3 color;
          if(uColormap == 0) {
            color = viridisColormap(t);
          } else if(uColormap == 1) {
            color = parulaSinColormap(t);
          } else if(uColormap == 2) {
            color = plasmaSinColormap(t);
          } else if(uColormap == 3) {
            color = thermalSinColormap(t);
          } else {
            color = viridisColormap(t);
          }
          fragColor = vec4(color, alpha);
        }
      `;

    /*******************************
     * Coordinate System Shaders
     *******************************/
    const csVsSource = `#version 300 es
        in vec3 aPosition;
        in vec3 aColor;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uModelViewMatrix;
        out vec3 vColor;
        void main() {
          gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
          vColor = aColor;
        }
      `;
    const csFsSource = `#version 300 es
        precision mediump float;
        in vec3 vColor;
        out vec4 fragColor;
        void main() {
          fragColor = vec4(vColor, 1.0);
        }
      `;

    /*******************************
     * Attractor Generators
     *******************************/
    class AttractorGenerator {
      constructor(params) {
        this.params = params;
      }
      generatePoints() {
        throw new Error("Method not implemented.");
      }
    }
    class AizawaAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          a = 0.95, b = 0.7, c = 0.6, d = 3.5, e = 0.25, f = 0.1, dt = 0.01, numPoints, initial = {
            x: 0.1,
            y: 0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = (z - b) * x - d * y;
          const dy = d * x + (z - b) * y;
          const dz = c + a * z - z ** 3 / 3 - x ** 2 + f * z * x ** 3;
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }
    class ArneodoAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          a = -5.5, b = 3.5, c = -1.0, dt = 0.001, numPoints, initial = {
            x: 0.1,
            y: 0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = y;
          const dy = z;
          const dz = -a * x - b * y - z + c * x ** 3;
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }
    class BoualiAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          alpha = 3.0, beta = 2.2, gamma = 1.0, mu = 1.2, dt = 0.001, numPoints, initial = {
            x: 1.0,
            y: 1.0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = alpha * x * (1 - y) - beta * z;
          const dy = -gamma * y * (1 - x ** 2);
          const dz = mu * x;
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }
    class BrukeshawAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          s = 10, v = 4.272, dt = 0.001, numPoints, initial = {
            x: 0.1,
            y: 0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = -s * (x + y);
          const dy = -y - s * x * z;
          const dz = s * x * y + v;
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }
    class LorenzAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          sigma = 10, rho = 28, beta = 8 / 3, dt = 0.001, numPoints, initial = {
            x: 0.1,
            y: 0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = sigma * (y - x);
          const dy = x * (rho - z) - y;
          const dz = x * y - beta * z;
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }
    class RosslerAttractor extends AttractorGenerator {
      generatePoints() {
        const {
          a = 0.2, b = 0.2, c = 5.7, dt = 0.001, numPoints, initial = {
            x: 0.1,
            y: 0,
            z: 0
          }
        } = this.params;
        let {
          x,
          y,
          z
        } = initial;
        const points = [];
        for (let i = 0; i < numPoints; i++) {
          const dx = -y - z;
          const dy = x + a * y;
          const dz = b + z * (x - c);
          x += dx * dt;
          y += dy * dt;
          z += dz * dt;
          points.push(x, y, z);
        }
        return new Float32Array(points);
      }
    }

    /*******************************
     * Camera (SRP & DIP)
     *******************************/
    class Camera {
      constructor() {
        this.angleX = 0;
        this.angleY = Math.PI / 4;
        this.distance = 80;
        this.center = [0, 0, 0];
      }
      rotate(deltaX, deltaY) {
        this.angleX += deltaX * 0.005;
        this.angleY += deltaY * 0.005;
        this.angleY = Math.min(Math.max(this.angleY, 0.1), Math.PI - 0.1);
      }
      zoom(deltaY) {
        this.distance += deltaY * 0.05;
        this.distance = Math.max(this.distance, 10);
      }
      getViewMatrix() {
        const viewMatrix = mat4.create();
        const eye = [
          this.distance * Math.sin(this.angleY) * Math.cos(this.angleX) + this.center[0],
          this.distance * Math.cos(this.angleY) + this.center[1],
          this.distance * Math.sin(this.angleY) * Math.sin(this.angleX) + this.center[2],
        ];
        mat4.lookAt(viewMatrix, eye, this.center, [0, 1, 0]);
        return viewMatrix;
      }
      setCenter(center) {
        this.center = center;
      }
    }

    /*******************************
     * ShaderProgram Wrapper
     *******************************/
    class ShaderProgram {
      constructor(gl, vsSource, fsSource, attribNames, uniformNames) {
        this.gl = gl;
        this.program = GLUtil.initShaderProgram(gl, vsSource, fsSource);
        this.attribLocations = {};
        this.uniformLocations = {};
        attribNames.forEach((name) => {
          this.attribLocations[name] = gl.getAttribLocation(this.program, name);
        });
        uniformNames.forEach((name) => {
          this.uniformLocations[name] = gl.getUniformLocation(this.program, name);
        });
      }
    }

    /*******************************
     * Renderer for Attractor Scene
     *******************************/
    class Renderer {
      constructor(gl, shaderProgram, camera) {
        this.gl = gl;
        this.shaderProgram = shaderProgram;
        this.camera = camera;
        this.buffers = null;
      }
      initBuffers(positions) {
        this.buffers = {};
        this.buffers.position = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.position);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
        this.buffers.numPoints = positions.length / 3;
        return this.buffers;
      }
      draw(buffers, drawCount, colormap) {
        const gl = this.gl;
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        const fieldOfView = (45 * Math.PI) / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 1000.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        const modelViewMatrix = this.camera.getViewMatrix();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(this.shaderProgram.attribLocations.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.shaderProgram.attribLocations.aPosition);
        gl.useProgram(this.shaderProgram.program);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uProjectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uModelViewMatrix, false, modelViewMatrix);
        gl.uniform1i(this.shaderProgram.uniformLocations.uColormap, colormap);
        const count = Math.min(drawCount, buffers.numPoints);
        gl.drawArrays(gl.POINTS, 0, count);
      }
    }

    /*******************************
     * Coordinate System Renderer
     *******************************/
    class CoordinateSystemRenderer {
      constructor(gl, shaderProgram, camera) {
        this.gl = gl;
        this.shaderProgram = shaderProgram;
        this.camera = camera;
        this.buffers = this.initBuffers();
      }
      initBuffers() {
        const gl = this.gl;
        const vertices = new Float32Array([
          0, 0, 0, 1, 0, 0, // X axis
          0, 0, 0, 0, 1, 0, // Y axis
          0, 0, 0, 0, 0, 1, // Z axis
        ]);
        const colors = new Float32Array([
          1, 0, 0, 1, 0, 0,
          0, 1, 0, 0, 1, 0,
          0, 0, 1, 0, 0, 1,
        ]);
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
        return {
          vertex: vertexBuffer,
          color: colorBuffer,
          numVertices: vertices.length / 3,
        };
      }
      draw() {
        const gl = this.gl;
        const canvasWidth = gl.canvas.width;
        const canvasHeight = gl.canvas.height;
        const widgetSize = 150;
        gl.viewport(canvasWidth - widgetSize - 10, 10, widgetSize, widgetSize);
        const projMatrix = mat4.create();
        mat4.ortho(projMatrix, -1, 1, -1, 1, -1, 1);
        const mvMatrix = mat4.create();
        mat4.rotate(mvMatrix, mvMatrix, this.camera.angleY, [1, 0, 0]);
        mat4.rotate(mvMatrix, mvMatrix, this.camera.angleX, [0, 1, 0]);
        gl.useProgram(this.shaderProgram.program);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uProjectionMatrix, false, projMatrix);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uModelViewMatrix, false, mvMatrix);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertex);
        gl.vertexAttribPointer(this.shaderProgram.attribLocations.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.shaderProgram.attribLocations.aPosition);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.color);
        gl.vertexAttribPointer(this.shaderProgram.attribLocations.aColor, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.shaderProgram.attribLocations.aColor);
        gl.drawArrays(gl.LINES, 0, this.buffers.numVertices);
        gl.viewport(0, 0, canvasWidth, canvasHeight);
      }
    }

    /*******************************
     * Particle Flow
     *******************************/
    class ParticleFlow {
      constructor(gl, attractorPositions, numParticles = 2000, speed = 0.5) {
        this.gl = gl;
        this.attractorPositions = attractorPositions;
        this.numParticles = numParticles;
        this.speed = speed;
        this.particleIndices = new Float32Array(numParticles);
        for (let i = 0; i < numParticles; i++) {
          this.particleIndices[i] = Math.random() * (attractorPositions.length / 3);
        }
        this.buffer = gl.createBuffer();
        this.shaderProgram = new ShaderProgram(
          gl,
          particleVsSource,
          particleFsSource,
          ["aPosition"],
          ["uProjectionMatrix", "uModelViewMatrix", "uPointSize", "uColormap"]
        );
      }
      update() {
        const totalPoints = this.attractorPositions.length / 3;
        for (let i = 0; i < this.numParticles; i++) {
          this.particleIndices[i] += this.speed;
          if (this.particleIndices[i] >= totalPoints) {
            this.particleIndices[i] -= totalPoints;
          }
        }
        const particlePositions = new Float32Array(this.numParticles * 3);
        for (let i = 0; i < this.numParticles; i++) {
          const index = Math.floor(this.particleIndices[i]) * 3;
          particlePositions[i * 3] = this.attractorPositions[index];
          particlePositions[i * 3 + 1] = this.attractorPositions[index + 1];
          particlePositions[i * 3 + 2] = this.attractorPositions[index + 2];
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, particlePositions, this.gl.DYNAMIC_DRAW);
      }
      draw(camera, colormap) {
        const gl = this.gl;
        const fieldOfView = (45 * Math.PI) / 180;
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 1000.0;
        const projectionMatrix = mat4.create();
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        const modelViewMatrix = camera.getViewMatrix();
        gl.useProgram(this.shaderProgram.program);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uProjectionMatrix, false, projectionMatrix);
        gl.uniformMatrix4fv(this.shaderProgram.uniformLocations.uModelViewMatrix, false, modelViewMatrix);
        gl.uniform1f(this.shaderProgram.uniformLocations.uPointSize, 6.0);
        gl.uniform1i(this.shaderProgram.uniformLocations.uColormap, colormap);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.vertexAttribPointer(this.shaderProgram.attribLocations.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(this.shaderProgram.attribLocations.aPosition);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.drawArrays(gl.POINTS, 0, this.numParticles);
        gl.disable(gl.BLEND);
      }
    }

    /*******************************
     * UI Controller
     *******************************/
    class UIController {
      constructor(app) {
        this.app = app;
        this.colormapMap = {
          viridis: 0,
          parula: 1,
          plasma: 2,
          thermal: 3,
        };
      }
      init() {
        const toggleControls = document.getElementById("toggleControls");
        const attractorSelect = document.getElementById("attractorSelect");
        const speedSlider = document.getElementById("speedSlider");
        const speedValue = document.getElementById("speedValue");
        const pointsInput = document.getElementById("pointsInput");
        const resetButton = document.getElementById("resetButton");
        const colormapSelect = document.getElementById("colormapSelect");
        const centerButton = document.getElementById("centerButton");
        const particleFlowToggle = document.getElementById("particleFlowToggle");
        const pauseButton = document.getElementById("pauseButton");

        toggleControls.addEventListener("click", (e) => {
          const ui = document.getElementById("ui");
          const currentDisplay = window.getComputedStyle(ui).display;
          if (currentDisplay === "none") {
            ui.style.display = "block";
          } else {
            ui.style.display = "none";
          }
        });
        speedSlider.addEventListener("input", (e) => {
          this.app.drawIncrement = Number(e.target.value);
          speedValue.textContent = e.target.value;
        });
        pointsInput.addEventListener("change", (e) => {
          this.app.totalPoints = Number(e.target.value);
          this.app.updateAttractor(this.app.currentAttractorType);
        });
        attractorSelect.addEventListener("change", (e) => {
          this.app.updateAttractor(e.target.value);
        });
        colormapSelect.addEventListener("change", (e) => {
          this.app.currentColormap = this.colormapMap[e.target.value] || 0;
        });
        centerButton.addEventListener("click", () => {
          this.app.recenterView();
        });
        resetButton.addEventListener("click", () => {
          this.app.updateAttractor(this.app.currentAttractorType);
        });
        particleFlowToggle.addEventListener("change", (e) => {
          this.app.toggleParticleFlow(e.target.checked);
        });
        pauseButton.addEventListener("click", () => {
          this.app.togglePause();
          pauseButton.textContent = this.app.paused ? "Play" : "Pause";
        });
        const xyButton = document.getElementById("xyButton");
        const yzButton = document.getElementById("yzButton");
        const xzButton = document.getElementById("xzButton");
        xyButton.addEventListener("click", () => {
          this.app.setViewXY();
        });
        yzButton.addEventListener("click", () => {
          this.app.setViewYZ();
        });
        xzButton.addEventListener("click", () => {
          this.app.setViewXZ();
        });
      }
    }

    /*******************************
     * Application
     *******************************/
    class Application {
      constructor(canvas) {
        this.canvas = canvas;
        this.gl = GLUtil.initWebGL(canvas);
        if (!this.gl) return;
        this.camera = new Camera();
        this.currentDrawCount = 0;
        this.drawIncrement = 5;
        this.totalPoints = 100000;
        this.currentAttractorType = "lorenz";
        this.currentColormap = 0;
        this.particleFlowEnabled = false;
        this.particleFlow = null;
        this.paused = false;
        // Create attractor generators.
        this.attractorGenerators = {
          aizawa: new AizawaAttractor({
            numPoints: this.totalPoints
          }),
          arneodo: new ArneodoAttractor({
            numPoints: this.totalPoints
          }),
          bouali: new BoualiAttractor({
            numPoints: this.totalPoints
          }),
          brukeshaw: new BrukeshawAttractor({
            numPoints: this.totalPoints
          }),
          lorenz: new LorenzAttractor({
            numPoints: this.totalPoints
          }),
          rossler: new RosslerAttractor({
            numPoints: this.totalPoints
          }),
        };
      }
      init() {
        this.attractorShader = new ShaderProgram(
          this.gl,
          vsSource,
          fsSource,
          ["aPosition"],
          ["uProjectionMatrix", "uModelViewMatrix", "uColormap"]
        );
        this.csShader = new ShaderProgram(
          this.gl,
          csVsSource,
          csFsSource,
          ["aPosition", "aColor"],
          ["uProjectionMatrix", "uModelViewMatrix"]
        );
        this.renderer = new Renderer(this.gl, this.attractorShader, this.camera);
        this.csRenderer = new CoordinateSystemRenderer(this.gl, this.csShader, this.camera);
        this.uiController = new UIController(this);
        this.uiController.init();
        this.updateAttractor(this.currentAttractorType);
        this.setupCameraControls();
        this.resizeCanvas();
        window.addEventListener("resize", () => this.resizeCanvas());
        this.animate();
      }
      updateAttractor(type) {
        this.currentAttractorType = type;
        const generator = this.attractorGenerators[type];
        generator.params.numPoints = this.totalPoints;
        const positions = generator.generatePoints();
        this.renderer.initBuffers(positions);
        this.currentDrawCount = 0;
        this.camera.setCenter([0, 0, 0]);
        this.currentPositions = positions;
        if (this.particleFlowEnabled) {
          if (this.particleFlow) {
            this.particleFlow.attractorPositions = positions;
          } else {
            this.particleFlow = new ParticleFlow(this.gl, positions, 2000, 0.5);
          }
        }
        this.recenterView();
      }
      recenterView() {
        if (!this.currentPositions) return;
        let minX = Infinity,
          minY = Infinity,
          minZ = Infinity;
        let maxX = -Infinity,
          maxY = -Infinity,
          maxZ = -Infinity;
        for (let i = 0; i < this.currentPositions.length; i += 3) {
          const x = this.currentPositions[i],
            y = this.currentPositions[i + 1],
            z = this.currentPositions[i + 2];
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          minZ = Math.min(minZ, z);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          maxZ = Math.max(maxZ, z);
        }
        const center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
        this.camera.setCenter(center);
        let radius = 0;
        for (let i = 0; i < this.currentPositions.length; i += 3) {
          const dx = this.currentPositions[i] - center[0],
            dy = this.currentPositions[i + 1] - center[1],
            dz = this.currentPositions[i + 2] - center[2];
          radius = Math.max(radius, Math.sqrt(dx * dx + dy * dy + dz * dz));
        }
        this.camera.distance = radius * 2;
      }
      setViewXY() {
        this.recenterView();
        this.camera.angleY = Math.PI / 2;
        this.camera.angleX = Math.PI / 2;
      }
      setViewYZ() {
        this.recenterView();
        this.camera.angleY = Math.PI / 2;
        this.camera.angleX = 0;
      }
      setViewXZ() {
        this.recenterView();
        this.camera.angleY = 0.0001;
        this.camera.angleX = 0;
      }
      toggleParticleFlow(enabled) {
        this.particleFlowEnabled = enabled;
        if (enabled && this.currentPositions && !this.particleFlow) {
          this.particleFlow = new ParticleFlow(this.gl, this.currentPositions, 2000, 0.5);
        }
      }
      togglePause() {
        this.paused = !this.paused;
      }
      setupCameraControls() {
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        this.canvas.addEventListener("mousedown", (e) => {
          isDragging = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          this.canvas.style.cursor = "grabbing";
        });
        this.canvas.addEventListener("mouseup", () => {
          isDragging = false;
          this.canvas.style.cursor = "grab";
        });
        this.canvas.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - lastMouseX;
          const deltaY = e.clientY - lastMouseY;
          this.camera.rotate(deltaX, deltaY);
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        });
        this.canvas.addEventListener("wheel", (e) => {
          e.preventDefault();
          this.camera.zoom(e.deltaY);
        });
      }
      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
      }
      animate() {
        if (this.paused) {
          requestAnimationFrame(() => this.animate());
          return;
        }
        if (this.renderer.buffers && this.currentDrawCount < this.renderer.buffers.numPoints) {
          this.currentDrawCount += this.drawIncrement;
        }
        this.renderer.draw(this.renderer.buffers, this.currentDrawCount, this.currentColormap);
        this.csRenderer.draw();
        if (this.particleFlowEnabled && this.particleFlow) {
          this.particleFlow.update();
          this.particleFlow.draw(this.camera, this.currentColormap);
        }
        const pointCounter = document.getElementById("pointCounter");
        if (pointCounter) {
          pointCounter.textContent = this.currentDrawCount;
        }
        requestAnimationFrame(() => this.animate());
      }
    }

    /*******************************
     * Application Entry Point
     *******************************/
    window.addEventListener("load", () => {
      const canvas = document.getElementById("glcanvas");
      const app = new Application(canvas);
      app.init();
    });
  </script>
</head>

<body>
  <button id="toggleControls">Show/Hide controls</button>
  <div id="ui">
    <label for="attractorSelect">Select Attractor:</label>
    <select id="attractorSelect">
      <option value="aizawa">Aizawa</option>
      <option value="arneodo">Arneodo</option>
      <option value="bouali">Bouali</option>
      <option value="brukeshaw">Bruke-Shaw</option>
      <option value="lorenz" selected="true">Lorenz</option>
      <option value="rossler">Rössler</option>
    </select>

    <label for="colormapSelect">Select Color Map:</label>
    <select id="colormapSelect">
      <option value="viridis">Viridis</option>
      <option value="parula">Parula</option>
      <option value="plasma">Plasma</option>
      <option value="thermal">Thermal</option>
    </select>

    <label for="speedSlider">Animation Speed:</label>
    <div class="range-container">
      <input type="range" id="speedSlider" min="1" max="1000" value="100" />
      <span id="speedValue">100</span>
    </div>

    <label for="pointsInput">Total Points:</label>
    <input type="number" id="pointsInput" value="100000" min="1000" step="1000" />
    <span id="pointCounter">0</span>

    <div class="particleFlow-group">
      <input type="checkbox" id="particleFlowToggle" />
      <label for="particleFlowToggle">Particle Flow</label>
    </div>

    <div class="play-group">
      <button id="pauseButton">Pause</button>
      <button id="resetButton">Reset</button>
    </div>

    <div class="xyz-group">
      <button id="centerButton">Fit</button>
      <button id="xyButton">XY</button>
      <button id="yzButton">YZ</button>
      <button id="xzButton">XZ</button>
    </div>
  </div>
  <canvas id="glcanvas"></canvas>
</body>

</html>
