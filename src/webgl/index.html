<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Animated Strange Attractors</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: grab;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 4px;
      font-family: sans-serif;
    }

    #ui label,
    #ui input,
    #ui select,
    #ui span,
    #ui button {
      display: block;
      margin-bottom: 5px;
    }

    #ui button {
      padding: 5px 10px;
    }
  </style>
  <!-- Include glMatrix for matrix math -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/3.4.2/gl-matrix-min.js"></script>
</head>

<body>
  <div id="ui">
    <label for="attractorSelect">Select Attractor:</label>
    <select id="attractorSelect">
      <option value="lorenz">Lorenz</option>
      <option value="rossler">Rössler</option>
    </select>
    <label for="speedSlider">Animation Speed (points per frame):</label>
    <input type="range" id="speedSlider" min="1" max="20" value="5">
    <span id="speedValue">5</span>
    <label for="pointsInput">Total Points:</label>
    <input type="number" id="pointsInput" value="10000" min="1000" step="1000">
    <button id="resetButton">Reset / Restart</button>
  </div>
  <canvas id="glcanvas"></canvas>
  <script>
    // Vertex shader program
    const vsSource = `
      attribute vec3 aPosition;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uModelViewMatrix;
      void main(void) {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
      }
    `;

    // Fragment shader program
    const fsSource = `
      precision mediump float;
      void main(void) {
        gl_FragColor = vec4(1.0, 0.6, 0.2, 1.0);
      }
    `;

    // Initialize WebGL context
    function initWebGL(canvas) {
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      if (!gl) {
        alert("Unable to initialize WebGL. Your browser may not support it.");
      }
      return gl;
    }

    // Compile a shader from source
    function loadShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('Error compiling shader: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Initialize the shader program
    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    }

    // Generate Lorenz attractor points using Euler integration
    function generateLorenzPoints({
      sigma = 10, rho = 28, beta = 8 / 3,
      dt = 0.01, numPoints = 10000,
      initial = { x: 0.1, y: 0, z: 0 }
    } = {}) {
      const points = [];
      let { x, y, z } = initial;
      for (let i = 0; i < numPoints; i++) {
        const dx = sigma * (y - x);
        const dy = x * (rho - z) - y;
        const dz = x * y - beta * z;
        x += dx * dt;
        y += dy * dt;
        z += dz * dt;
        points.push(x, y, z);
      }
      return new Float32Array(points);
    }

    // Generate Rössler attractor points using Euler integration
    function generateRosslerPoints({
      a = 0.2, b = 0.2, c = 5.7,
      dt = 0.02, numPoints = 10000,
      initial = { x: 0.1, y: 0, z: 0 }
    } = {}) {
      const points = [];
      let { x, y, z } = initial;
      for (let i = 0; i < numPoints; i++) {
        const dx = -y - z;
        const dy = x + a * y;
        const dz = b + z * (x - c);
        x += dx * dt;
        y += dy * dt;
        z += dz * dt;
        points.push(x, y, z);
      }
      return new Float32Array(points);
    }

    // Initialize buffers with provided positions data
    function initBuffers(gl, positions) {
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      return {
        position: positionBuffer,
        numPoints: positions.length / 3,
      };
    }

    // Global variables for attractor buffers, current selection, and animation progress
    let currentAttractor = 'lorenz';
    let buffers = null;
    let gl = null;
    let currentDrawCount = 0;  // How many points to draw so far
    let drawIncrement = 5;    // Points added per frame (controlled by slider)
    let totalPoints = 10000;   // Total points to generate (controlled by input)

    // Global camera parameters
    let cameraAngleX = 0;
    let cameraAngleY = Math.PI / 4;
    let cameraDistance = 80;

    // Mouse interaction variables
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Setup camera controls: rotation and zoom
    function setupCameraControls(canvas) {
      canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });
      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });
      canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        cameraAngleX += deltaX * 0.005;
        cameraAngleY += deltaY * 0.005;
        cameraAngleY = Math.min(Math.max(cameraAngleY, 0.1), Math.PI - 0.1);
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance += e.deltaY * 0.05;
        cameraDistance = Math.max(cameraDistance, 10);
      });
    }

    // Draw the scene.
    function drawScene(gl, programInfo, buffers, drawCount) {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const fieldOfView = 45 * Math.PI / 180;
      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      const zNear = 0.1;
      const zFar = 1000.0;
      const projectionMatrix = glMatrix.mat4.create();
      glMatrix.mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

      // Compute camera position in spherical coordinates
      const eye = [
        cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX),
        cameraDistance * Math.cos(cameraAngleY),
        cameraDistance * Math.sin(cameraAngleY) * Math.sin(cameraAngleX)
      ];
      const center = [0, 0, 0];
      const up = [0, 1, 0];
      const modelViewMatrix = glMatrix.mat4.create();
      glMatrix.mat4.lookAt(modelViewMatrix, eye, center, up);

      // Bind buffer and set up attribute pointers
      {
        const numComponents = 3;
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0;
        const offset = 0;
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
          programInfo.attribLocations.aPosition,
          numComponents,
          type,
          normalize,
          stride,
          offset);
        gl.enableVertexAttribArray(programInfo.attribLocations.aPosition);
      }

      gl.useProgram(programInfo.program);
      gl.uniformMatrix4fv(programInfo.uniformLocations.uProjectionMatrix, false, projectionMatrix);
      gl.uniformMatrix4fv(programInfo.uniformLocations.uModelViewMatrix, false, modelViewMatrix);
      // Only draw up to drawCount (or all points if drawCount exceeds total)
      const count = Math.min(drawCount, buffers.numPoints);
      gl.drawArrays(gl.LINE_STRIP, 0, count);
    }

    // Function to update the buffer based on the selected attractor.
    // Resets the animation progress.
    function updateAttractor(gl, attractorType) {
      let positions;
      const params = { numPoints: totalPoints };
      if (attractorType === 'lorenz') {
        positions = generateLorenzPoints(params);
      } else if (attractorType === 'rossler') {
        positions = generateRosslerPoints(params);
      }
      buffers = initBuffers(gl, positions);
      currentDrawCount = 0; // Reset animation progress when switching or updating
    }

    // Main function to start the WebGL application
    function main() {
      const canvas = document.getElementById('glcanvas');
      gl = initWebGL(canvas);
      if (!gl) return;

      // Set up camera controls
      setupCameraControls(canvas);

      // Initialize shaders and program
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          aPosition: gl.getAttribLocation(shaderProgram, 'aPosition'),
        },
        uniformLocations: {
          uProjectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
          uModelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
        },
      };

      // Get UI elements for additional controls
      const attractorSelect = document.getElementById('attractorSelect');
      const speedSlider = document.getElementById('speedSlider');
      const speedValue = document.getElementById('speedValue');
      const pointsInput = document.getElementById('pointsInput');
      const resetButton = document.getElementById('resetButton');

      // Update speed control UI
      speedSlider.addEventListener('input', (e) => {
        drawIncrement = Number(e.target.value);
        speedValue.textContent = e.target.value;
      });

      // Update points count and regenerate the attractor when input changes
      pointsInput.addEventListener('change', (e) => {
        totalPoints = Number(e.target.value);
        updateAttractor(gl, currentAttractor);
      });

      // Handle attractor switching from dropdown
      attractorSelect.addEventListener('change', (e) => {
        currentAttractor = e.target.value;
        updateAttractor(gl, currentAttractor);
      });

      // Reset button: clear the canvas and restart the animation.
      resetButton.addEventListener('click', () => {
        updateAttractor(gl, currentAttractor);
      });

      // Initialize attractor buffers with the default (Lorenz)
      updateAttractor(gl, currentAttractor);

      // Resize canvas to fill the window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Animation loop: update the scene continuously
      function animate() {
        if (currentDrawCount < buffers.numPoints) {
          currentDrawCount += drawIncrement;
        }
        drawScene(gl, programInfo, buffers, currentDrawCount);
        requestAnimationFrame(animate);
      }
      animate();
    }

    window.onload = main;
  </script>
</body>

</html>
