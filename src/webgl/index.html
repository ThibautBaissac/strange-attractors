<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Animated Attractors with Coordinate System & Modern WebGL</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: grab;
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 4px;
      font-family: sans-serif;
    }

    #ui label,
    #ui input,
    #ui select,
    #ui span,
    #ui button {
      display: block;
      margin-bottom: 5px;
    }

    #ui button {
      padding: 5px 10px;
    }
  </style>
  <script type="module">
    import { mat4 } from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.2/src/index.js';

    // Main attractor shaders (using WebGL2)
    // The vertex shader now passes the raw position to the fragment shader.
    const vsSource = `#version 300 es
      in vec3 aPosition;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uModelViewMatrix;
      out vec3 vPosition;
      void main() {
        vec4 pos = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        gl_Position = pos;
        vPosition = aPosition;
      }
      `;
    // The fragment shader uses the passed position and the selected colormap (via uniform uColormap)
    const fsSource = `#version 300 es
      precision mediump float;
      in vec3 vPosition;
      uniform int uColormap;
      out vec4 fragColor;

      vec3 defaultColormap(vec3 pos) {
        // Simple mapping: use sine functions for each component, normalized to [0,1]
        return (sin(pos) + 1.0) * 0.5;
      }

      vec3 blueColormap(vec3 pos) {
        return vec3(0.0, (sin(pos.y) + 1.0) * 0.5, 1.0);
      }

      vec3 greenColormap(vec3 pos) {
        return vec3((sin(pos.x) + 1.0) * 0.5, 1.0, (sin(pos.z) + 1.0) * 0.5);
      }

      vec3 redColormap(vec3 pos) {
        return vec3(1.0, (sin(pos.y) + 1.0) * 0.5, (sin(pos.z) + 1.0) * 0.5);
      }

      vec3 rainbowColormap(vec3 pos) {
        float r = (sin(pos.x) + 1.0) * 0.5;
        float g = (sin(pos.y + 1.0) + 1.0) * 0.5;
        float b = (sin(pos.z + 2.0) + 1.0) * 0.5;
        return vec3(r, g, b);
      }

      void main() {
        vec3 color;
        if(uColormap == 0) {
          color = defaultColormap(vPosition);
        } else if(uColormap == 1) {
          color = blueColormap(vPosition);
        } else if(uColormap == 2) {
          color = greenColormap(vPosition);
        } else if(uColormap == 3) {
          color = redColormap(vPosition);
        } else if(uColormap == 4) {
          color = rainbowColormap(vPosition);
        } else {
          color = defaultColormap(vPosition);
        }
        fragColor = vec4(color, 1.0);
      }
      `;

    // Coordinate system widget shaders (unchanged)
    const csVsSource = `#version 300 es
      in vec3 aPosition;
      in vec3 aColor;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uModelViewMatrix;
      out vec3 vColor;
      void main() {
        gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
        vColor = aColor;
      }
      `;
    const csFsSource = `#version 300 es
      precision mediump float;
      in vec3 vColor;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(vColor, 1.0);
      }
      `;

    // Initialize WebGL context (try WebGL2 first)
    const initWebGL = (canvas) => {
      let gl = canvas.getContext('webgl2');
      if (!gl) {
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
          alert('Unable to initialize WebGL. Your browser may not support it.');
        }
      }
      return gl;
    };

    // Compile a shader from source
    const loadShader = (gl, type, source) => {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('Error compiling shader: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    };

    // Initialize shader program
    const initShaderProgram = (gl, vsSource, fsSource) => {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
      }
      return shaderProgram;
    };

    // Generate attractor points
    const generateLorenzPoints = ({
      sigma = 10,
      rho = 28,
      beta = 8 / 3,
      dt = 0.01,
      numPoints = 10000,
      initial = { x: 0.1, y: 0, z: 0 }
    } = {}) => {
      const points = [];
      let { x, y, z } = initial;
      for (let i = 0; i < numPoints; i++) {
        const dx = sigma * (y - x);
        const dy = x * (rho - z) - y;
        const dz = x * y - beta * z;
        x += dx * dt;
        y += dy * dt;
        z += dz * dt;
        points.push(x, y, z);
      }
      return new Float32Array(points);
    };

    const generateRosslerPoints = ({
      a = 0.2,
      b = 0.2,
      c = 5.7,
      dt = 0.02,
      numPoints = 10000,
      initial = { x: 0.1, y: 0, z: 0 }
    } = {}) => {
      const points = [];
      let { x, y, z } = initial;
      for (let i = 0; i < numPoints; i++) {
        const dx = -y - z;
        const dy = x + a * y;
        const dz = b + z * (x - c);
        x += dx * dt;
        y += dy * dt;
        z += dz * dt;
        points.push(x, y, z);
      }
      return new Float32Array(points);
    };

    // Global variables to hold attractor data and center.
    let currentPositions = null;
    let attractorCenter = [0, 0, 0];

    // Initialize buffers for attractor points and store positions for later centering.
    const initBuffers = (gl, positions) => {
      currentPositions = positions; // store the positions array globally
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
      return {
        position: positionBuffer,
        numPoints: positions.length / 3
      };
    };

    // Create buffers for the coordinate system widget (three axes)
    const createCSBuffers = (gl) => {
      // Vertices for axes: each axis from (0,0,0) to (1,0,0), etc.
      const vertices = new Float32Array([
        0, 0, 0, 1, 0, 0,  // X axis
        0, 0, 0, 0, 1, 0,  // Y axis
        0, 0, 0, 0, 0, 1   // Z axis
      ]);
      // Colors for each vertex (red for X, green for Y, blue for Z)
      const colors = new Float32Array([
        1, 0, 0, 1, 0, 0,  // Red X
        0, 1, 0, 0, 1, 0,  // Green Y
        0, 0, 1, 0, 0, 1   // Blue Z
      ]);
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      const colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      return {
        vertex: vertexBuffer,
        color: colorBuffer,
        numVertices: vertices.length / 3
      };
    };

    // Global camera parameters
    let cameraAngleX = 0;
    let cameraAngleY = Math.PI / 4;
    let cameraDistance = 80;

    // Mouse interaction state
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Set up camera controls
    const setupCameraControls = (canvas) => {
      canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.style.cursor = 'grabbing';
      });
      canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
      });
      canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const deltaX = e.clientX - lastMouseX;
        const deltaY = e.clientY - lastMouseY;
        cameraAngleX += deltaX * 0.005;
        cameraAngleY += deltaY * 0.005;
        cameraAngleY = Math.min(Math.max(cameraAngleY, 0.1), Math.PI - 0.1);
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      });
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        cameraDistance += e.deltaY * 0.05;
        cameraDistance = Math.max(cameraDistance, 10);
      });
    };

    // Global state for colormap selection.
    // We map UI string values to integer IDs that the shader uses:
    // 0: default, 1: blue, 2: green, 3: red, 4: rainbow
    let currentColormap = 0;
    const colormapMap = {
      'default': 0,
      'blue': 1,
      'green': 2,
      'red': 3,
      'rainbow': 4
    };

    // Draw the main attractor scene (using position-based color)
    const drawScene = (gl, programInfo, buffers, drawCount) => {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clearDepth(1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      const fieldOfView = (45 * Math.PI) / 180;
      const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
      const zNear = 0.1;
      const zFar = 1000.0;
      const projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

      // Compute camera position using spherical coordinates.
      // Note that we now use "attractorCenter" as the look-at target.
      const eye = [
        cameraDistance * Math.sin(cameraAngleY) * Math.cos(cameraAngleX) + attractorCenter[0],
        cameraDistance * Math.cos(cameraAngleY) + attractorCenter[1],
        cameraDistance * Math.sin(cameraAngleY) * Math.sin(cameraAngleX) + attractorCenter[2]
      ];
      const center = attractorCenter;
      const up = [0, 1, 0];
      const modelViewMatrix = mat4.create();
      mat4.lookAt(modelViewMatrix, eye, center, up);

      // Bind main attractor position buffer and configure attribute
      gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
      gl.vertexAttribPointer(programInfo.attribLocations.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(programInfo.attribLocations.aPosition);

      gl.useProgram(programInfo.program);
      gl.uniformMatrix4fv(programInfo.uniformLocations.uProjectionMatrix, false, projectionMatrix);
      gl.uniformMatrix4fv(programInfo.uniformLocations.uModelViewMatrix, false, modelViewMatrix);
      // Pass the colormap ID to the shader
      gl.uniform1i(programInfo.uniformLocations.uColormap, currentColormap);

      const count = Math.min(drawCount, buffers.numPoints);
      gl.drawArrays(gl.LINE_STRIP, 0, count);
    };

    // Draw the coordinate system widget in the top-right corner
    const drawCoordinateSystem = (gl, csProgramInfo, csBuffers) => {
      // Save current viewport dimensions
      const canvasWidth = gl.canvas.width;
      const canvasHeight = gl.canvas.height;
      // Define widget size (e.g., 150x150 pixels)
      const widgetSize = 150;
      gl.viewport(canvasWidth - widgetSize - 10, 10, widgetSize, widgetSize);

      // Use an orthographic projection
      const projMatrix = mat4.create();
      mat4.ortho(projMatrix, -1, 1, -1, 1, -1, 1);

      // Create a model view matrix that reflects the current camera rotation.
      const mvMatrix = mat4.create();
      mat4.rotate(mvMatrix, mvMatrix, cameraAngleY, [1, 0, 0]);
      mat4.rotate(mvMatrix, mvMatrix, cameraAngleX, [0, 1, 0]);

      gl.useProgram(csProgramInfo.program);
      gl.uniformMatrix4fv(csProgramInfo.uniformLocations.uProjectionMatrix, false, projMatrix);
      gl.uniformMatrix4fv(csProgramInfo.uniformLocations.uModelViewMatrix, false, mvMatrix);

      // Bind vertex positions for the widget
      gl.bindBuffer(gl.ARRAY_BUFFER, csBuffers.vertex);
      gl.vertexAttribPointer(csProgramInfo.attribLocations.aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(csProgramInfo.attribLocations.aPosition);

      // Bind vertex colors for the widget
      gl.bindBuffer(gl.ARRAY_BUFFER, csBuffers.color);
      gl.vertexAttribPointer(csProgramInfo.attribLocations.aColor, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(csProgramInfo.attribLocations.aColor);

      // Draw axes as lines (each axis is two vertices)
      gl.drawArrays(gl.LINES, 0, csBuffers.numVertices);

      // Reset viewport to full canvas for next frame
      gl.viewport(0, 0, canvasWidth, canvasHeight);
    };

    // Global state for attractor rendering
    let currentAttractor = 'lorenz';
    let buffers = null;
    let currentDrawCount = 0;
    let drawIncrement = 5;
    let totalPoints = 10000;
    let gl = null;

    // Update attractor data based on selection
    const updateAttractor = (attractorType) => {
      const params = { numPoints: totalPoints };
      const positions =
        attractorType === 'lorenz'
          ? generateLorenzPoints(params)
          : generateRosslerPoints(params);
      buffers = initBuffers(gl, positions);
      currentDrawCount = 0;
      // Reset attractor center to [0, 0, 0] until user re-centers.
      attractorCenter = [0, 0, 0];
    };

    // Recenter and fit the attractor in the viewport by computing its bounding sphere.
    const recenterView = () => {
      if (!currentPositions) return;
      let minX = Infinity, minY = Infinity, minZ = Infinity;
      let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
      for (let i = 0; i < currentPositions.length; i += 3) {
        const x = currentPositions[i];
        const y = currentPositions[i + 1];
        const z = currentPositions[i + 2];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (z < minZ) minZ = z;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
        if (z > maxZ) maxZ = z;
      }
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      const centerZ = (minZ + maxZ) / 2;
      attractorCenter = [centerX, centerY, centerZ];
      // Compute the maximum distance from the center to any point
      let radius = 0;
      for (let i = 0; i < currentPositions.length; i += 3) {
        const dx = currentPositions[i] - centerX;
        const dy = currentPositions[i + 1] - centerY;
        const dz = currentPositions[i + 2] - centerZ;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
        if (dist > radius) radius = dist;
      }
      // Set camera distance to roughly twice the radius for a good fit.
      cameraDistance = radius * 2;
    };

    // Main function to initialize the app
    const main = () => {
      const canvas = document.getElementById('glcanvas');
      gl = initWebGL(canvas);
      if (!gl) return;
      setupCameraControls(canvas);

      // Main attractor shader program and info
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          aPosition: gl.getAttribLocation(shaderProgram, 'aPosition')
        },
        uniformLocations: {
          uProjectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
          uModelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
          uColormap: gl.getUniformLocation(shaderProgram, 'uColormap')
        }
      };

      // Coordinate system shader program and buffers
      const csShaderProgram = initShaderProgram(gl, csVsSource, csFsSource);
      const csProgramInfo = {
        program: csShaderProgram,
        attribLocations: {
          aPosition: gl.getAttribLocation(csShaderProgram, 'aPosition'),
          aColor: gl.getAttribLocation(csShaderProgram, 'aColor')
        },
        uniformLocations: {
          uProjectionMatrix: gl.getUniformLocation(csShaderProgram, 'uProjectionMatrix'),
          uModelViewMatrix: gl.getUniformLocation(csShaderProgram, 'uModelViewMatrix')
        }
      };
      const csBuffers = createCSBuffers(gl);

      // UI Elements
      const attractorSelect = document.getElementById('attractorSelect');
      const speedSlider = document.getElementById('speedSlider');
      const speedValue = document.getElementById('speedValue');
      const pointsInput = document.getElementById('pointsInput');
      const resetButton = document.getElementById('resetButton');
      const colormapSelect = document.getElementById('colormapSelect');
      const centerButton = document.getElementById('centerButton');

      speedSlider.addEventListener('input', (e) => {
        drawIncrement = Number(e.target.value);
        speedValue.textContent = e.target.value;
      });

      pointsInput.addEventListener('change', (e) => {
        totalPoints = Number(e.target.value);
        updateAttractor(currentAttractor);
      });

      attractorSelect.addEventListener('change', (e) => {
        currentAttractor = e.target.value;
        updateAttractor(currentAttractor);
      });

      // Update colormap based on the selection.
      colormapSelect.addEventListener('change', (e) => {
        const selected = e.target.value;
        currentColormap = colormapMap[selected] || 0;
      });

      // Center / Fit Attractor button
      centerButton.addEventListener('click', () => {
        recenterView();
      });

      resetButton.addEventListener('click', () => {
        updateAttractor(currentAttractor);
      });

      updateAttractor(currentAttractor);

      // Resize canvas to fill window
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      };
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // Animation loop: draw main scene and then coordinate widget.
      const animate = () => {
        if (currentDrawCount < buffers.numPoints) {
          currentDrawCount += drawIncrement;
        }
        drawScene(gl, programInfo, buffers, currentDrawCount);
        drawCoordinateSystem(gl, csProgramInfo, csBuffers);
        requestAnimationFrame(animate);
      };
      animate();
    };

    window.addEventListener('load', main);
  </script>
</head>

<body>
  <div id="ui">
    <label for="attractorSelect">Select Attractor:</label>
    <select id="attractorSelect">
      <option value="lorenz">Lorenz</option>
      <option value="rossler">Rössler</option>
    </select>
    <label for="colormapSelect">Select Color Map:</label>
    <select id="colormapSelect">
      <option value="default">Default</option>
      <option value="blue">Blue</option>
      <option value="green">Green</option>
      <option value="red">Red</option>
      <option value="rainbow">Rainbow</option>
    </select>
    <label for="speedSlider">Animation Speed (points per frame):</label>
    <input type="range" id="speedSlider" min="1" max="20" value="5" />
    <span id="speedValue">5</span>
    <label for="pointsInput">Total Points:</label>
    <input type="number" id="pointsInput" value="10000" min="1000" step="1000" />
    <button id="resetButton">Reset / Restart</button>
    <button id="centerButton">Center / Fit Attractor</button>
  </div>
  <canvas id="glcanvas"></canvas>
</body>

</html>
